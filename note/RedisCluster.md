# Redis 集群

## 概念

1. **集群**
   在多个 Redis 节点之间进行数据共享
   - 不支持操作多个键的命令
     多个键可能会分配在不同的节点上，会降低 Redis 集群的性能，导致不可预测的行为
   - 通过分区来提供一定程序的可用性，集群有部分节点失效也可以处理命令请求
2. **集群数据共享**
   使用数据分片来实现，一个 Redis 包含了 16384 个哈希槽（Hash Slot），集群使用 CRC16(key) % 16384 来计算 key 属于哪个槽。
   集群中的每个节点负责处理一部分哈希槽。 
   因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。
3. **主从复制**
   每个节点都有 1 ~ N 个节点，1 个为主节点（master），另一个为从节点 (slave)
   如果主从节点都下线，集群将无法正常运行
4. **集群的一致性保证**
   Redis 集群不保证数据的强一致性，在特定的条件下，集群可能会丢失已经被执行过的写命令。
   【例】异步复制：
   - 客户端向主节点 B 发送一条写命令。
   - 主节点 B 执行写命令，并向客户端返回命令回复。
   - 主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。
   如你所见， 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。
   【例】网络分裂：
   举个例子， 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， 而 A1 、B1 、C1 分别为三个主节点的从节点， 另外还有一个客户端 Z1 。
   假设集群中发生网络分裂， 那么集群可能会分裂为两方， 大多数（majority）的一方包含节点 A 、C 、A1 、B1 和 C1 ， 而少数（minority）的一方则包含节点 B 和客户端 Z1 。
   在网络分裂期间， 主节点 B 仍然会接受 Z1 发送的写命令：
   - 如果网络分裂出现的时间很短， 那么集群会继续正常运行；
   - 但是， 如果网络分裂出现的时间足够长， 使得大多数一方将从节点 B1 设置为新的主节点， 并使用 B1 来代替原来的主节点 B ， 那么 Z1 发送给主节点 B 的写命令将丢失。
   注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：
   - 对于大多数一方来说， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么集群会将这个主节点视为下线， 并使用从节点来代替这个主节点继续工作。
   - 对于少数一方， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么它将停止处理写命令， 并向客户端报告错误。

## 问题

1. **为什么 Redis 集群最大槽数是 16384？**
   Redis 作者在 Github 上的回答：why redis-cluster use 16384 slots?
   简书：https://www.jianshu.com/p/de268f62f99b
   在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用char进行bitmap压缩后是2k（2 * 8 (8 bit) * 1024(1k) = 2K），也就是说使用2k的空间创建了16k的槽数。
   虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k（8 * 8 (8 bit) * 1024(1k) = 8K），也就是说需要需要8k的心跳包，作者认为这样做不太值得；并且一般情况下一个redis集群不会有超过1000个master节点，所以16k的槽位是个比较合适的选择。
2. 
